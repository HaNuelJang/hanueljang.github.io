[ { "title": "OAuth 2.0", "url": "/posts/OAuth2.0/", "categories": "Server, Protocol", "tags": "Server", "date": "2022-05-16 11:59:10 +0900", "snippet": "목표최근 어느 사이트, 앱, 게임등 로그인 시 간편로그인 또는 연동하여 가입하기 등의 회원가입/로그인 방식을 사용하고 있다.왜 이런 기능이 생겨났고, 사용하고 있는지 알아보자.다른 서비스의 자원을 효율적이고 안전하게 가져올 수 있는 방법간편로그인, 연동을 통해 무엇을 하는가?로그인 시 사용하는 간편로그인, 연동을 통해서 해당 서비스에서 무엇을 가져올까?키워드를 확인해보자. 로그인, 간편로그인, 연동, 다른 서비스로 뽑을 수 있다.나름 해석해본다면 A서비스에 로그인을 하기위해 간편로그인을 사용하고, 간편로그인으로 B서비스의 리소스(자원)를 가져와 사용하는것.서비스는 다양해지고 새로운 서비스를 이용 할 때 마다 회원가입을 진행해야한다. 매번 회원가입을 진행해야하는 번거로움, 서비스마다 가입해야하는 양식도 재각각일뿐만 아니라 각 계정을 사용자가 직접 관리해야하는 불편함도 증가하게 된다. 따라서 사용자는 A서비스를 사용할 때의 가입/로그인 절차를 간소화 시킬 수 있는 장점이 있다.간편로그인을 도입하여 필수적으로 필요한 리소스를 타서비스에서 제공받아 재사용하는 개방형 표준 프로토콜(OAuth2.0)이 등장하게 되었다.굳이 연동을 할 필요가 있을까? 직접 ID,PW를 등록한다면?가장 원시적인 방법부터.먼저 A서비스가 B서비스에서 특정유저(U)의 자원을 필요로 한다고 가정해보자. U의 리소스에 접근하려면 U의 식별자인 ID와 암호인 PW를 필요하게 된다.그리고 A서비스는 U의 ID,PW를 영속성 컨텍스트(persistence context)에 저장하고 필요시마다 꺼내어 B서비스에 요청하면 된다.간단하다. 하지만 문제점은 많다. 사용자는 A서비스를 신뢰할 수 있을까? = 내 정보를 해당 서비스에게 믿고 맞길 수 있을까? B서비스는 A서비스를 신뢰할 수 있을까? = 실제 유저인가? 해커인가? A서비스의 보안 문제가 B서비스로 확장된다. = 타 서비스의 보안문제를 떠안게 된다. PW가 변경된다면 타서비스에 저장된 PW를 변경해야 한다. 네트워크 통신중에 중요 정보가 빈번하게 노출된다.… 등 많은 불편/불안요소가 내제되어 있다.해결책 OAuth2.0 OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다. 이 매커니즘은 여러 기업들에 의해 사용되는데, 이를테면 아마존, 구글, 페이스북, 마이크로소프트, 트위터가 있으며 사용자들이 타사 애플리케이션이나 웹사이트의 계정에 관한 정보를 공유할 수 있게 허용한다.OAuth(Open Authorization)를 사용하여 해결 할 수 있다. 먼저 다른 서비스에 대한 ID,PW를 사용하지 않는다. 따라서 PW노출, 이중으로 관리해야하는 문제 등 해결 할 수 있다. (PW가 변경되어도 해당 서비스에서는 PW를 관리해야할 필요가 없으므로 문제가 되지 않는다.)인가서버를 통해 인증( Authentification )을 거치고, 인가서버로부터 인가( Authorization )(특정코드, 토큰)를 받아 필요한 리소스를 획득한다.OAuth 인증방식(4가지) Authorization Code Grant Type │ 권한 부여 승인 코드 방식 Implicit Grant Type │ 암묵적 승인 방식 Resource Owner Password Credentials Grant Type │ 자원 소유자 자격증명 승인 방식 Client Credentials Grant Type │ 클라이언트 자격증명 승인 방식Authorization Code Grant Type │ 권한 부여 승인 코드 방식보편적인 방식으로 간편로그인에서 사용한다.Client는 사용자의 자격증명에 대해 관여하지 않으며, 사용자에게서 특정스코프를 증명하는 인가코드를 획득, Access token으로 리소스를 요청하는 방식이다. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&amp;gt;| Server | | | | | | -+----(C)-- Authorization Code ---&amp;lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&amp;gt;---(D)-- Authorization Code ---------&#39; | | Client | &amp;amp; Redirection URI | | | | | |&amp;lt;---(E)----- Access Token -------------------&#39; +---------+ (w/ Optional Refresh Token) FLOWA. Client는 User-Agent에게 필요로하는 리소스를 알려주고, 인가코드를 요청한다. User-Agent는 Client의 요청으로 토대로 Authorization Server에게 해당 내용을 전달한다.B. Authorization Server는 Resource Owner에게 인증(Authentification)을 요청하고 Client의 요청에 대한 승인여부를 묻는다.C. Authorization Server는 승인여부를 확인하고, User-Agent에게 인가코드를 반환한다. User-Agent는 다시 Client에게 인가코드를 전달한다.D. Client는 Authorization Server에게 인가코드를 전달한다.E. Authorization Server는 Client에게 Access token을 전달한다.(필요에 따라 Refresh token을 같이 전달한다.)마지막으로 Client는 Resource Server에게 Access token을 전달하고, 인가받은 리소스를 받아온다.Implicit Grant Type │ 암묵적 승인 방식스크립트 언어를 사용하는 브라우저에 사용하는 방식이다.인가코드 방식과 유사하지만, 인가코드를 사용하지않고 바로 Access token을 전달하여 승인하는 방식이다. 승인절차가 간소화 되어 응답성과 효율성은 뛰어나지만, Access token이 URI에 노출되는 단점이 있다. (Refresh token 사용 불가)(과거에는 page reload가 없이는 URI를 조작 할 수 없었기 때문에 암묵적 승인 방식이 사용되었으나, 지금은 page reload가 없어도 URI조작이 가능하다. Access token의 노출, Refresh token 미사용에 따른 Access token 관리가 어려움, (수명이 다한)Access token 갱신 시 추가 인증 및 통신 비용증가 등 득에 비해 실이 많은 방식으로 추천하지 않는다.) +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp;amp; Redirection URI ---&amp;gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --&amp;gt;| Server | | | | | | |&amp;lt;---(C)--- Redirection URI ----&amp;lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----&amp;gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |&amp;lt;---(E)------- Script ---------&amp;lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ FLOWA. Client는 User-Agent에게 필요로하는 리소스를 알려주고, 인가코드를 요청한다. User-Agent는 Client의 요청으로 토대로 Authorization Server에게 해당 내용을 전달한다.B. Authorization Server는 Resource Owner에게 인증(Authentification)을 요청하고 Client의 요청에 대한 승인여부를 묻는다.C. Authorization Server는 승인여부를 확인하고, User-Agent에게 Access token이 포함된 URI를 반환한다.D. User-Agent가 Web-Hosted Client Resource에게 Access token이 포함된 URI를 전달한다.E. Web-Hosted Client Resource가 URI에서 Access token을 추출한다.F. Web-Hosted Client Resource가 User-Agent에게 Access token을 전달한다.G. User-Agent가 Client에게 Access token을 전달한다.Resource Owner Password Credentials Grant Type │ 자원 소유자 자격증명 승인 방식username, password로 Access Token을 받는 방식.Client, Authrization Server, Resource Server가 모두 신뢰 할 수 있는 경우(=자신의 서비스) 사용하는 방식.(Refresh token 사용 가능) +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |&amp;gt;--(B)---- Resource Owner -------&amp;gt;| | | | Password Credentials | Authorization | | Client | | Server | | |&amp;lt;--(C)---- Access Token ---------&amp;lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ FLOWA. Resource Owner는 Client에게 username, password를 전달한다.B. Client는 Authorization Server에게 전달받은 자격증명으로 Access token을 요청한다.C. Authorization Server는 Client에게 인증결과에 따라 Access token을 전달한다.Client Credentials Grant Type │ 클라이언트 자격증명 승인 방식Client의 자격증명만으로 Access Token을 획득하는 방식.OAuth의 권한 부여 방식 중 가장 간단한 방식으로 클라이언트 자신이 관리하는 리소스 혹은 인가서버에 해당 클라이언트를 위한 제한된 리소스 접근 권한이 설정되어 있는 경우 사용한다.(Refresh token 사용 불가) +---------+ +---------------+ | | | | | |&amp;gt;--(A)- Client Authentication ---&amp;gt;| Authorization | | Client | | Server | | |&amp;lt;--(B)---- Access Token ---------&amp;lt;| | | | | | +---------+ +---------------+ FLOWA. Client는 Authorization Server에 Access token을 요청한다.B. Authorization Server은 Client에게 Access token을 전달한다.참조공식문서_https://datatracker.ietf.org/doc/html/rfc6749" }, { "title": "Bean Life-Cycle", "url": "/posts/Bean/", "categories": "Spring, Spring Basic", "tags": "Bean, Life-Cycle", "date": "2022-05-04 11:59:10 +0900", "snippet": "목표Spring에서 Bean을 사용함으로써 언제 생성되고, 어떻게 사용되는지, 언제 소멸하는지에 대한 Life-Cycle을 파악하고, 각 단계에서 수행되는 기능들에 대해 알아본다.BeanBean의 Life-Cycle은 Spring Container이 관리한다. 먼저 프로그램이 실행되면 Spring Container가 만들어진다. 해당 컨테이너에 관련된 Bean들이 생성되고, 이후 Bean들은 의존성 주입을 한다. 마지막으로 프로그램이 종료되면서 Bean들은 소멸단계를 거쳐 최종적으로 메모리에서 사라지게 된다.https://www.netjstech.com/2016/03/spring-bean-life-cycle.html콜백 메소드Bean 초기화시 또는 제거시 실행되는 콜백 메소드를 Override하여, 개발자가 개입하여 추가 기능을 구현 할 수 있다. 다음의 3가지 방식으로 구현 할 수 있다.초기화 @PostConstruct, @PreDestroy InitializingBean, DisposableBean Inteface구현 init-method, destroy-method 선언부가작업 Aware Interface BeanPostProcessor초기화 콜백 메소드제거 콜백 메소드Aware InterfaceBeanPostProcessor Interface(BPP)Bean의 초기화 전,후에 필요한 부가작업을 구현 할 수 있는 콜백 인터페이스를 제공한다." }, { "title": "(Servlet / Spring / Web Application) Context, Container", "url": "/posts/servlet/", "categories": "Spring, Spring Basic", "tags": "Context, Container", "date": "2022-04-25 11:59:10 +0900", "snippet": "계기spring을 공부하던 도중 Context, Container의 정의에 대해 혼란이 생겼고, 관련 자료를 검색해보았다. 생각보다 이에 대해 지식이 부족한 것을 느꼈다. 그동안 서버를 개발하면서 Web의 기초적인 지식없이 비지니스 로직만 생각한것 같다. 각 단어들의 개념과 역할, 더불어 Web Server, WAS(Web Application Server), Spring의 전체적인 흐름을 파악하고 깊이있게 공부해 보고자 이 글을 작성하게 되었다.목표 Spring으로 개념을 넓히기 위해 기반기술을 익힌다. Servlet Context, Servlet Container, Web Application Context, Spring Container… 등 각 개념과 역할을 파악한다. 전체적인 웹의 흐름을 파악한다.Step1. Web Server초창기 Web Service는 HTML의 링크기능 기반의 서비스로 돌아가는 Static(정적)인 콘텐츠를 제공했다.시간이 지남에 따라 정보는 점점 쌓이고, 기존의 정적인 Web Service의 한계가 생기기 시작했다. 사용자들은 점점 더 다양한 정보와 실시간으로 변하는 dynamic(동적)한 서비스를 원했다. 그렇게 Script언어(Client-Side Script)가 등장하였고 동적인 페이지를 생산할 수 있게 되었다. 이때까지만 해도 서버는 사용자에게 서비스를 제공하는데 큰 부담이 없었다. Web Server의 기능 정적컨텐츠를 Client에게 제공한다. HTTP를 통한 Client의 Ruquest/Response를 처리한다. https://www.educative.io/edpresso/web-server-vs-application-serverStep2. Web Container(=Servlet Container), WAS하지만 사용자마다 요구하는 동적데이터가 다양해졌고, 그에따른 처리시간이 증가하게 되었다. 당연히 서버도 부담이 커지기 시작했으며 처리 시간도 증가하게 되었다. 이를 해소하기 위해 개발자들은 정적데이터와 동적데이터를 분리하는 방법을 고안하였고, SPA(Single Page Application)라는 개념이 등장하게 되었다.SPA란? 서버로부터 완전히 새로운 페이지를 불러오는 것이 아니라, 화면을 업데이트하는데 필요한 데이터만 서버에서 전달받아 브라우저에서 해당하는 부분만 업데이트하는 방식. ex)AJAX). Web Server는 정적데이터를 제공하기 위한 목적으로 개발되었고, 동적데이터를 효율적으로 처리 하기 위해 Web Container가 등장하게 되었다.Web Container는 다른 웹 응용프로그램(JSP, Servlet…)을 실행시키기 위한 실행환경이다. 동적데이터를 생산하고 그 결과를 정적데이터로 변환하여 Web Server에게 전달한다. Web Container = Servlet Container로 여길 수 있다. Web Container의 기능 Servlet을 생성,실행,소멸등 생명주기를 관리하는 주체가 된다. 쓰레드를 통해서 작업이 보다 효과적으로 이루어지도록 지원 Web Server &amp;lt;-&amp;gt; Web application의 Socket Connection관리, 주고 받는 데이터 파싱, session, cookie, thread 관리를 대신 해준다. Q.Web Server도 CGI(Common Gateway Interface)를 통해 동적처리가 가능 하던데?가능하다. 단, 처리방식의 차이가 존재한다.CGI는 Request에 하나의 프로세스를 생성하여 통신한다.WAS는 Requset에 Thread를 생성하여 통신한다.따라서 자원을 효율적으로 처리 할 수 있는 WAS를 주로 사용한다. https://www.educative.io/edpresso/web-server-vs-application-serverWeb Server + Web Container를 결합한 WAS(Web Application Server)가 등장하게 된다.Web Server는 클라이언트가 정적데이터를 요청하면 앞단에서 빠르게 제공하고, 동적데이터가 필요하면 WAS 에 요청을 보내고, WAS 가 처리한 데이터를 클라이언트에 전달한다.Step3. WAS 구조 동작과정 Client는 Web Server에 Http Request를 보낸다. Web Server는 WAS에 Http Request를 보낸다. WAS는 HttpServletRequest, HttpServletResponse객체 생성한다. WAS는 web.xml을 참조하여 Servlet에 대한 Thread를 생성한다. Thread는 Servlet-Service의 doGet() 또는 doPost()메소드를 호출한다. Servlet은 HttpServletResponse객체에 결과를 담아 WAS에 반환한다. WAS는 HttpServletResponse객체를 Web Server에 전달한다. Thread를 종료한다. // HttpServletRequest, HttpServletResponse객체 소멸 Servlet은 Singleton으로 동작하며, 최초 요청이 들어올때 init()이 실행되고 서버종료시 destroy()가 실행된다.Step4. Servlet Container vs Servlet Context Servlet Context Servlet Container &amp;lt;-&amp;gt; Servlet 간 통신을 위한 인터페이스 Web Application마다 각각의 ServletContext가 생성 Servlet끼리 자원을 공유하는데 사용https://www.oreilly.com/library/view/head-first-servlets/9780596516680/ch05s10.html Servlet Container Servlet을 생성,실행,소멸등 Life-Cicle을 관리하는 주체가 된다. 쓰레드를 통해서 작업이 보다 효과적으로 이루어지도록 지원 Web Server &amp;lt;-&amp;gt; Web application의 Socket Connection관리, 주고 받는 데이터 파싱, session, cookie, thread 관리를 대신 해준다. Step5. Spring ContainerSpring Container는 Spring에서의 Bean(=스프링이 제어권을 가지고 직접생성하며 의존관계를 부여하는 객체)의 Life-Cicle을 관리하며 IoC/DI를 제공해주는 역할을 수행한다. 즉, Spring Container에게 위임/관리함으로써 개발자는 비지니스 로직에 더욱 집중 할 수 있는 환경이 되었다. BeanFactoryBean인스턴스를 생성하고 의존관계를 설정하는 기본적인 IoC Container. ApplicationContextBeanFactory인터페이스를 상속받은 하위 인터페이스BeanFactory 구현 + 별도의 정보를 참고해 추가기능을 제공하는 클래스ex) 빈 객체 라이프 사이클, 파일과 같은 자원 처리 추상화, 메시지 지원 및 국제화 지원, 이벤트 지원, XML 스키마 확장을 통한 편리한 설정 Servlet WebApplicationContext URL 관련된 설정을 하는 Context servlet-context.xml을 참조 DispatcherSevlet에 필요한 Bean 관리(@Controller, Intercepter, ViewResolver, HandlerMapping…) Root WebApplicationContext Servlet과 관련없는 설정을 하는 Context root-context.xml,applicationContext.xml을 참조 ApplicationContext에 필요한 Bean 관리(@Service, @Repository, @Configuration, @Component) 서로다른 Context간 Bean을 공유 https://gowoonsori.com/spring/architecture/" }, { "title": "객체지향 설계 연습_1", "url": "/posts/step1/", "categories": "Practice", "tags": "OOP design", "date": "2022-04-25 11:59:10 +0900", "snippet": "목표시나리오를 토대로 간단한 커피 주문 프로그램을 설계해 본다.복잡한 기능은 제외하고 필수적인 부분만 생각한다.시나리오 손님이 가게를 들어온다. 손님은 메뉴판을 확인한다. 손님은 메뉴를 고른다. 손님은 금액을 지불한다. 손님은 커피를 주문한다. 바리스타는 손님의 주문을 확인한다. 바리스타는 주문받은 커피를 만든다. 바리스타는 만든 커피를 손님에게 준다. 손님은 커피를 받는다.객체 도출우선 시나리오에서 객체화 할 수 있는 대상을 찾아본다.먼저 자주 등장하는 주 키워드를 탐색한다. 손님, 바리스타, 커피, 주문 다음 객체화 가능한 대상을 탐색한다. 메뉴판, 메뉴, 금액, 주문은 추후 추가하였다.손님의 책임은 주문을 요청하고, 완성된 제품을 받으면 끝난다. 하지만 주문을 따로 분리하지 않았을 경우, 손님은 주문이라는 역할도 함께 수행하게 된다. 따라서 손님과 주문이라는 커플링이 생기기 때문에 이를 분리할 필요가 있다.객체들간의 관계와 책임을 확인한다.객체 상태/행위 도출먼저 객체간 인터페이스를 도출하고, 각 인터페이스 필요한 필드를 구성한다.클래스 다이어그램실제코드" }, { "title": "프로그램_설계_1", "url": "/posts/Programming/", "categories": "Look back on", "tags": "history", "date": "2022-04-25 10:59:10 +0900", "snippet": "들어가기에 앞서서…*_내가 글을 쓰게 된 계기*_내가 하고있는 프로그래밍 방식과 문제점*_내가 해야 할 개선방안본 글은 나를 돌아보기 위해 작성된 글이다. 길면 길고 짧으면 짧은 경험기간이지만, 그동안 경험하고 느낀것을 정리해보고그 토대로 앞으로의 나아갈 방향과 목표를 정하기 위해 글을 쓰게 되었다.아직은 배워야 할 것이 산더미 처럼 뒤에 쌓여있다. 내가 쓰고자하는 것이 옳고 그름인지도 정확히 판별 할 수 없다.하지만 조금씩 정리하고, 기초를 되돌아보고, 앞서나가 기술을 살펴보기도하고, 이렇게 다듬다 보면 나의 목표와 방향이 확실해 지지 않을까?내가 글을 쓰게 된 계기프로젝트의 시작은 고객의 요구사항으로부터.요구사항을 토대로 프로그램의 아키텍쳐가 정해지고, 기본설계가 시작된다. 나는 기본설계를 Flow로 정리 하면서 프로젝트를 시작한다. 그러나 여기까지. 잘 정리해둔 기본설계를 잊어버리고 그렇게 프로젝트를 진행한다. 어느정도 시간이 흘러 요구사항을 확인하기 위해, 그리고 내가 그렸던 기본설계를… 하고 작성해둔 파일을 열어본다.아뿔싸! 시간이 얼마 지나지 않았는데도 벌써 초반에 세웠던 계획가 현재 진행된 프로젝트를 비교하면 많은부분 차이가 생긴것을 확인한다.프로젝트 기한에 쫓기고 있는데 다시 피드백하고 고쳐야 할까? 모르겠다 우선 진행하자? 선택은 항상 후자로. 그렇게 챗바퀴가 굴러간다. 항상. 제자리에서. 고민하고 또 고민해서 도출해낸 기본설계. 잘 정리해두었던 기본설계가 그렇게 무너진다.내가 하는 프로그래밍 방식이 옳은 것 일까? 나에게 맞는 방식일까?프로젝트를 진행하다 보면 항상 어느부분에서 막히게 된다. 가장 기본적인것 부터 시작해서.왜그럴까?내가 하고있는 문제점나는 내가 잘 알지.나는 똑똑한 사람이 아니다. 한번 본것을 이해하고, 머리로 생각한 것을 그대로 뚝딱 만들어 내는 능력이 부족하다. 하지만 잘 알고있으면서도 항상 머리로만 생각한다. 머리속은 복잡하고 계획은 많은데 결국엔 서로 얽혀 꼬이기 시작한다. 그러다보니 반복반복 도돌이표. 끝날 기미가 보이지 않는다. 머리도 정리가 안된다. 어떻게 해야 할까?내가 해야 할 개선방안기록을 하자나는 ERD를 좋아한다. 프로그램의 크기를 가늠 할 수 있다. 모듈들의 관계 어떻게 통신하는지 파악 할 수 있다. 클래스 구성과 관계를 파악 할 수 있다. 처리 프로세스를 파악 할 수 있다. 문서화 되어 있기 때문에, 꼬이는 일이 없다.내가 좋아하고 잘하는 것을 잊지 말자. 기록 또 기록이다. 기록하면서 정리해라.반복하고 개선하면서 생각을 정리하고 빠른 피드백을 눈으로 확인해라.생각에 갇히지 말고, 진행 해라생각에 갇히다 보면 시야가 좁아진다. 알고있는것도 잊게 된다. 개발은 작은것부터 생각은 큰것부터.지금 안된다고 삽질해도 지나간 시간은 돌아오지 않는다. 우선 진행해라. 진하다 보면 막혔던 생각들이 자연스레 뚫리는 경우가 다반사인것 같다.모르면 동료, 선배, 후배에게 물어봐라. 항상 빠른 피드백으로 확인하고, 정리해라.나의 장점을 내가 죽이지 말자. 기록하고, 정리하고, 다듬고.처음부터 새로운 개념들과 기술들을 익히기보단, 내가 모르는것부터 차근차근 쌓아가자.화려한 것에 현혹되지 말아라. 결국 남는것은 기본이다." }, { "title": "Spring - IoC, DI, AOC", "url": "/posts/Spring2/", "categories": "Spring, Spring Basic", "tags": "Spring, IoC, DI, AOC", "date": "2022-04-19 00:59:10 +0900", "snippet": "용어정리 Bean Spring(Spring IoC 컨테이너)에 의하여 생성되고 관리되는 자바 객체일반적인 new 연산자로 어떤 객체를 생성했을 때 그 객체는 빈이 아니다.ApplicationContext.getBean()으로 얻어질 수 있는 객체는 빈이다.즉 Spring에서의 Bean은 ApplicationContext가 알고있는 객체, 즉 ApplicationContext가 만들어서 그 안에 담고있는 객체를 의미한다.BeanFactoryApplicationContext" }, { "title": "Spring", "url": "/posts/Spring/", "categories": "Spring, Spring Basic", "tags": "Spring", "date": "2022-04-19 00:59:10 +0900", "snippet": "Spring자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크애플리케이션 프레임워크프레임워크는 특정 업무, 기술에 특화된 목표를 가지고 만들어진다. 예를 들어 View의 레이아웃 별로 정의해 두면 자동으로 완성된 View를 만들어주거나, DB와 객체를 맵핑해주는 ORM 기술 등 이 있다.하지만 스프링은 이와 다르게 애플리케이션 프레임워크라는 특징을 갖고 있다.애플리케이션 프레임워크는 특정 업무, 기술에 특화되지 않고 애플리케이션 전 영역을 포괄하는 범용적인 프레임워크이다.따라서 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 목표를 두는 프레임워크이다.경량급Spring이전 EJB는 과도한 엔지니어링으로 인한 무겁고 복잡한 개발환경이었다. EJB가 동작하려면 WAS가 필요했고, 난해한 설정과 까다로운 패키징, 서버 배치 등 제대로된 개발환경을 갖추지 않고는 개발하기가 힘들었다.그에 반해 Spring은 단순한 개발툴과 기본적인 개발환경으로도 EJB의 주요한 기능을 대부분 사용 가능하면서 애플리케이션 개발하기에 충분하다. 불필요한 기능들을 제거하고, 프레임워크, 서버 환경에 의존적인 부분을 개선하여 간단한 설정만으로도 개발을 수월하게 진행 할 수 있게 되었다.따라서 스프링은 고성능에 준하는 기술수준과 그것을 훨씬 빠르고 간편하게 작성하게 해주는 프레임워크로 생산성과 품질 면에서 유리하다는 것이 경량급이라는 스프링의 특징이다.자바 엔터프라이즈 개발을 편하게편리한 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 신경을 쓰지 않고도, 애플리케이션의 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다.스프링은 애플리케이션 개발자들이 스프링이라는 프레임워크가 제공하는 기술이 아니라 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.초기 스프링의 기본 설정과 적용 기술만 잘 선택한다면, 이후 개발중에는 스프링과 관련된 코드나 API등 개발자가 신경 쓸 일이 없다.오픈소스소스가 모두에게 공개되고, 자신의 목적에 맞게 사용할 수 있을 뿐만 아니라, 필요하면 마음대로 수정할 수 있고, 수정된 소스를 다시 공개적을고 배포하는 자유도 혀용된다.또한 다양한 환경에서 개발하는 개발자가 자신이 경험한 문제점이나 발견한 버그 등을 그때마다 커뮤니티를 통해 개발팀에 전달하기 때문에 잠재적인 버그와 문제점이 빠르게 발견되고 해결될 수 있다.다만 소스에 대한 신뢰성과 안정성, 유지보수가 지속적으로 일어날지에 대한 의문점이 남아있으므로 주의해야 하는 면도 있다." }, { "title": "스레드(Thread) - 심화", "url": "/posts/Thread2/", "categories": "JAVA, JAVA Basic", "tags": "JAVA, Thread", "date": "2022-04-18 00:59:10 +0900", "snippet": "스레드 동기화(Synchronized)멀티 스레드는 여러 작업을 동시성을 갖고 처리 할 수 있는 이점이 있다. 하지만 때로는 그 결과가 기대한 값과 다른 결과가 나오는 일이 발생한다.스레드의 특징인 자원을 공유하는 것이 문제점이 된다. 서로 다른 스레드가 하나의 공유 자원에 동시에 접근하는 경우 그렇다.이러한 문제점을 해결하는 방법을 알아 보고자 한다. 메소드 동기화 메소드 블록 동기화 동기 vs 비동기동기(synchronous): 작업요청 후 해당결과를 받아야 다음 작업을 처리, 순차적으로 작업을 진행비동기(Asynchronous): 작업요청 후 결과를 받지않아도 다음 작업을 처리, 동시에 여러 작업을 진행메소드 동기화메소드 자체에 public synchronized void …(){}를 선언class Sync{ int cnt = 0; boolean isSleep = false; public synchronized void printCnt(){ Thread thread = Thread.currentThread(); if (isSleep) { System.out.println(&quot;Critical Section is LOCKED&quot;) return; } isSleep = true; try{ Thread.sleep(SecureRandom.getInstanceStrong().nextInt(3000)); cnt++; isSleep = false; }catch (Exception e) {} }} 메소드 동기화의 단점 synchronized 함수 블록 synchronized 함수가 포함된 객체 전체 block 메소드 블록 동기화메소드 내부에 synchronized(Object){} 메소드 블록 생성class Sync{ int cnt = 0; boolean isSleep = false; public void printCnt(){ Thread thread = Thread.currentThread(); if (isSleep) { System.out.println(&quot;Critical Section is LOCKED&quot;) return; } isSleep = true; synchronized(this) { try{ Thread.sleep(SecureRandom.getInstanceStrong().nextInt(3000)); cnt++; isSleep = false; }catch (Exception e) {} } }}함수 내부의 일부분만 블록 선언하여 동기화처리 진행메소드의 paramsynchronized(this)으로 각각 다른 Object를 선언하여 블록의 범위를 상세하게 조절가능 NOTEsynchronized 함수가 포함된 Object가 lockstatic synchronized 함수가 포함된 Class가 lock스레드 풀" }, { "title": "스레드(Thread) - 개념", "url": "/posts/Thread/", "categories": "JAVA, JAVA Basic", "tags": "JAVA, Thread", "date": "2022-04-17 00:59:10 +0900", "snippet": "스레드란?프로그램: 실행파일프로세스: CPU를 차지하면서 수행하는 주체, 프로그램의 인스턴스스레드: 프로세스 내부에서 자원을 공유하며 처리하는 단위, 작업을 효율적으로 처리하기 위한 모델스레드 종류 일반 스레드(User Thread) = 일반적으로 구현하는 스레드, Main Thread()도 포함된다. 데몬 스레드(Daemon Thread) = 데몬 스레드는 일반 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드. ex) GCNOTE 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다.싱글 스레드 같은 경우 Main Thread가 종료되면 프로세스도 종료되지만,멀티 스레드는 Main Thread가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. 주 스레드가 종료되면 데몬 스레드 더는 존재 의미가 없기에 강제로 종료된다. setDaemon(Boolean) 메소드: 일반 스레드 -&amp;gt; 데몬 스레드 생성, 데몬 스레드 -&amp;gt; 일반 스레드 생성이 가능하다. setDeamon메소드는 스레드가 실행되기 전에 만 호출 할 수 있다. A스레드를 Thread.start() 이후 A스레드.setDaemon()메소드가 호출되면 IlegalThreadStateException 예외가 발생한다. 스레드 생성, 실행 java.lang.Thread java.lang.Runnable방법1 extends Threadpublic class CustomThread extends Thread { @Override public void run() { int sum = 0; for (int index = 0; index &amp;lt; 10; index++) { sum += index; System.out.println(sum); } System.out.println(&quot;result : &quot; + sum); }}public static void main(String args[]){ Thread subTread1 = new CustomThread(); Thread subTread2 = new CustomThread(); subTread1.start(); subTread2.start();}방법2 implements Runnablepublic class Task implements Runnable { @Override public void run() { int sum = 0; for (int index = 0; index &amp;lt; 10; index++) { sum += index; System.out.println(sum); } System.out.println(&quot;result : &quot; + sum); }}public static void main(String args[]){ Runnable task = new Task(); Thread subTread1 = new Thread(task); Thread subTread2 = new Thread(task); subTread1.setName(&quot;스레드 1번.&quot;); subTread2.setName(&quot;스레드 2번.&quot;); subTread1.start(); subTread2.start();}NOTE run() 메소드가 종료되면 스레드는 종료된다. 한 번 종료된 스레드는 다시 시작할 수 없다 = 다시 스레드 객체를 생성하고 등록해야 한다. 스레드는 다른 스레드를 강제종료 시킬 수 있다. 스레드 상태 상태 설명 NEW 스레드가 생성되었지만, 아직 실행할 준비가 되지 않은 상태. RUNNABLE Thread.start() 호출 이후, 스케쥴링을 기다리고있는 실행준비 상태. RUNNING RUNNABLE에서 선택되어 실제로 TASK가 수행되는 상태. WAITING wait(), join() 호출 이후의 상태. 다른 스레드가 notify(), notifyAll()을 호출하기 까지 상태 유지. TIMED_WAITING sleep(n), wait(n)을 호출하여 n ms동안 잠을 자는 상태. BLOCKED 스레드가 I/O 작업 요청을 하면 JVM이 자동으로 BLOCK. BLOCK해제 시 자동으로 RUNNABLE로 상태로 전환. TERMINATED 스레드 종료. 스레드 조작 메소드 interrupt(), sleep(), join(), wait(), yield(), notify(), notifyAll() 상태 설명 join() 다른 스레드들이 종료되기를 기다리고, 최종적으로 해당 스레드의 처리 수행 interrupt() 점유자원을 해제하고 해당 스레드 강제 종료, WATTING상태 일 경우에만 처리되는 메소드 yield() 해당 스레드 상태를 RUNNING -&amp;gt; RUNNABLE로 전환하여 우선순위를 뒤로 미루고 , 다른 스레드를 우선으로 실행 notify() WATTING상태의 스레드에게 알리고, 그 스레드의 상태를 WATTING -&amp;gt; RUNNABLE로 전환시킴 notifyAll() notify()와 동일하지만, WATTING상태의 모든 스레드에게 알림 sleep() vs wait(): 점유자원 해제유무wait(),notify(),notifyAll()는 synchronized 블록 내에서만 사용 할 수 있다.스레드 그룹용도에 따라 스레드를 그룹으로 나누고 관리 할 수 있다.java.lang.ThreadGroup 자바에서의 모든 스레드는 특정 스레드 그룹의 멤버로서 존재 Main 스레드 그룹 인스턴스는 Main 스레드 생성해서 애플리케이션 실행 포인트인 main() 메소드를 호출 개발자가 생성한 모든 스레드는 main 스레드 그룹을 루트로해서 트리 구조로 구성 모든 스레드는 반드시 스레드 그룹에 포함되어야 한다. 스레드 그룹을 지정하지 않고 생성한 쓰레드는 자동적으로 Main 쓰레드 그룹에 속하게 된다.// 스레드 그룹 생성자ThreadGroup(String name) // 새로운 name의 스레드 그룹 생성ThreadGroup(ThreadGroup parent , String name) // parent에 속하는 새로운 name의 스레드 그룹 생성JAVA DOCjava_doc_Threadjava_doc_Runnablejava_doc_ThreadGroupjava_doc_Object wait() notify() notifyAll())" }, { "title": "Garbage Collection", "url": "/posts/GC/", "categories": "JAVA, JVM", "tags": "JAVA, GC", "date": "2022-04-11 10:59:10 +0900", "snippet": "GC(Garbage Collection)자동으로 Heap영역의 메모리를 관리하는 쓰레드. Heap에서 Unreachable Object들을 mark후 sweep하는 작업을 처리하여 Heap을 확보한다. Heap은 다음과 같은 영역으로 나뉜다. YG(Minor GC)Eden: 처음 객체가 생성될 때 적재되는 공간Survivor1,2: Eden의 메모리가 가득차면 Minor GC가 발생한다. 이때 reachable Object를 Survivor영역으로 옮기는 작업을 한다.(단, Survivor영역의 한곳은 항상 비워둔다.) OG(Major GC)YG영역에서 장기간 살아남은 객체는 OG로 이동하게 된다. Metaspace(~Java7까지 Permanent영역) Permanent Generation은 힙 메모리 영역중에 하나로 자바 애플리케이션을 실행할때 클래스의 메타데이터(클래스의 이름, 생성자, 필드, 메소드 정보…)를 저장하는 영역이다.(Java 7기준) OutOfMemoryError: PermGen Space error 는 더이상 볼 수 없고 JVM 옵션으로 사용했던 PermSize 와 MaxPermSize는 더이상 사용할 필요가 없다. 이 대신에 MetaspaceSize 및 MaxMetaspaceSize가 새롭게 사용되게 되었다. 기존 Permanent영역은 고정된 크기로 할당되었다. 하지만 동적으로 생성되는 Class데이터들로 이로인해 OOM관련 이슈가 존재했었다. 이를 해결하기 위해 OS레벨에서 관리되는 Native메모리 영역으로 변경되면서, 개발자는 Metaspace의 영역에 대해 크게 의식할 필요가 없어지게 되었다.YG/OG비교 메모리 크기: YG &amp;lt; OG처리빈도: YG &amp;gt; OG Why? 대체로 객체는 장시간 참조되지 않는다. 그리고 오래된 객체는 대부분 새로 생성된 객체를 참조하지 않는다. 따라서 YG의 Minor GC는 빈번하게 처리된다.GC시나리오 Eden이 가득차면 reachable Object을 탐색하고 Survivor1로 옮긴다. (Eden 메모리 초기화) 다음 Minor GC에서는 Eden, Survivor1을 탐색하고 Survivor2로 옮긴다. (Eden, Survivor1 메모리 초기화) 다음 Minor GC에서는 Eden, Survivor2를 탐색하고 Survivor1로 옮긴다. (Eden, Survivor2 메모리 초기화) 이 작업이 반복되면서 Survivor영역의 객체들은 Age값을 갖고, Survivor영역에서 다른 Survivor영역으로 이동될때 Age값이 증가한다. Age값이 설정된 임계치를 넘게되면, 해당 객체들은 OG영역으로 이동하게 된다. OG의 메모리가 가득차면, Major GC가 발생한다. OG의 reachable Object들을 탐색 후, 메모리를 정리한다.GC알고리즘 Serial GC Parallel GC Parallel Old GC CMS GC(Concurrent Mark &amp;amp; Sweep GC) G1 GC(Garbage First GC)Serial GCHeap의 앞부분부터 확인(Mark)하여 살아있는 것만 남기고(Sweep), 객체들이 연속되도록 Compaction 하는 작업기본적인 Mark-Sweep-Compaction 알고리즘에 해당싱글 쓰레드로 작업을 수행하며, Stop-The-World 시간이 상대적으로 길다.(서버환경에서는 사용하지 않는것이 바람직하다)/* 사용옵션 */-XX:+UseSerialGCParallel GCSerial GC의 멀티 쓰레드 방식/* 사용옵션 */-XX:+UseParallelGC //Minor GC만 멀티 스레드로 동작하고, Major GC는 싱글 스레드 동작 /* 스레드 수 변경 옵션 */ /* 기본적으로 JVM이 구동되는 환경의 CPU 코어 개수에 맞춰서 N개의 GC가 수행된다. */ -XX:ParallelGCThreads=N(스레드수)Parallel Old GCParallel GC와 다른점은 Mark-Summary-Compaction 단계를 거쳐서 객체를 식별Summary 에 해당하는 작업이 GC를 수행한 영역에 대해서 살아있는 객체를 식별한다는 작업/* 사용옵션 */-XX:+UseParallelOldGC //Minor GC, Major GC 멀티 스레드로 동작 CMS GC(Concurrent Mark &amp;amp; Sweep GC)Stop-The-World 시간이 짧다.Compaction을 수행하지는 않기 때문에 메모리 단편화가 발생한다. 이때 Concurrent mode failure 경고가 나면서 Compaction 작업을 수행하는데, 다른 GC의 Stop-The-World 시간보다도 긴 시간이 소요돼서 서버 환경에서는 위험할 수 있다. Initial Mark: GC Tree의 Root중 살아있는 객체만 선별(STW시간이 매우 짧다.) Concurrent Mark: Mark단계에서 선별된 객체부터 Tree탐색을 하면서 참조중인 살아있는 객체를 확인한다. Remark: 위 단계를 한번더 검증한다.(새로 추가되거나 참조가 끊긴 객체를 확인한다. STW발생-멀티쓰레드로 동작) Concurrent Sweep: GC대상을 정리한다./* 사용옵션 */-XX:+UseConcMarkSweepGCG1 GC(Garbage First GC)JDK7 부터 공식적으로 도입된 서버형 GC. 대용량 메모리에 적합한 솔루션을 제공하기 위해 사용한다.JDK11 부터 공식적인 GC알고리즘으로 적용. G1 GC는 메모리를 페이징 하듯이 논리적인 단위(Region)로 나눠서 관리한다는 것이다.Region이라는 논리적인 단위로 메모리를 관리하여 CMS와 달리 Compaction 단계를 진행하고 메모리 단편화 문제를 없앴다.또한 STW의 시간을 예측할 수 있다는 것이 G1 GC의 큰 장점 중 하나이다.General GC Mark절차 Softly References Weakly References finalize Phantomly References Memory SweepGC대상 세분화Root Set이 되기 위한 조건 각각의 쓰레드의 Stack 영역에 존재하는 Local Variable, Operand Stack에 존재하는 참조 값 등 JNI (Java Native Interface)를 통해 생성된 객체들 메서드 영역의 정적 변수에 의한 참조Reachable: (Root Set을 기준으로)Heap 영역에 존재하고 있는 객체의 유효한 참조가 존재하는 경우 Unreahable: (Root Set을 기준으로)유효한 참조가 존재하지 않는 경우 - __`GC대상`__ ![helloworld-329631-2](https://user-images.githubusercontent.com/103012019/163067083-03750d3b-eb5d-4bc3-934b-0897f498ebc7.png)Soft, Weak, Phantom Referencejava.lang.ref는 SoftReference, WeakReference, phantom reference를 클래스 형태로 제공SoftReference - JVM의 메모리가 부족한 경우에만 힙영역에서 제거되고 메모리가 부족하지 않다면 굳이 제거하지 않는다.null인 경우 GC대상WeakReference - WeakReference만 남아있는 경우, GC대상PhantomReference - 이전작업이 끝나고 메모리가 해제 된 것을 확인 후에 다음 작업을 진행할 때 사용.생성자에서 무조건 ReferenceQueue를 받습니다.Strengths of Reachabilityjava.lang.ref 패키지를 이용하여 reachable 객체들을 모두 다른 접근성 수준을 가질 수 있다. 따라서 개발자가 GC대상 판별 작업에 개입할수 있게 되었다. strongly 일반적으로 생성되는 Object softly (SoftReference) 사용 빈도수를 계산하여 GC대상 여부 판별 /* 사용 빈도수 계산 */ XX:SoftRefLRUPolicyMSPerMB = NUMBER/* 예시 */GC 시간 &amp;gt; NUMBER * Heap Memory→ 옵션 설정 값이 1000이라면 1,000ms / MB * 100MB = 100,000 ms = 100 sec 즉 회수 시간은 100초 weakly (WeakReference) GC발생시 해당 객체들은 Sweep대상 phantomly reachable 다른 모든 단계에 포함되지 않는 Object -&amp;gt; finalize를 통해 다음 GC의 Sweep대상으로 특정 queue에 저장 unReachable Object 유효 참조가 없는 객체 참조https://d2.naver.com/helloworld/329631" }, { "title": "JVM Memory Structure", "url": "/posts/java-memory/", "categories": "JAVA, JVM", "tags": "JAVA, JVM", "date": "2022-04-09 10:59:10 +0900", "snippet": "JVM은 무엇인가 JAVA Virtual Machine JRE의 한 부분(구성요소) OS에 영향을 받지 않고 클래스파일(ByteCode)을 실행 GC(메모리 관리)수행JVM은 무엇을 하는가먼저 작성한 Java소스를 Java Compiler 의해 Class파일(ByteCode)로 변환한다. JVM은 OS로부터 메모리를 할당받는다. ByteCode를 읽어온다. ByteCode를 검증한다. (유효한 컴파일러에 의해 생성되었는지 확인) ByteCode를 적재한다. (할당받은 메모리를 용도에 따라 나눠서 관리) ByteCode를 실행한다. (기계어 변경, 명령어 단위 실행)JVM의 ArchitectureClass Loader프로그램이 실행되면 Class Loader는 필요한 ByteCode를 동적으로 읽어온다. 해당 단계에서 ByteCode를 검증하고 초기화하는 작업을 진행한다. 마지막으로 Runtime Data Area에 적재한다.Runtime Data Area프로그램이 실행되면서 할당받은 메모리 영역이다. 아래의 6개의 영역으로 세분화하여 메모리를 관리한다. Method Area Heap Stack PC Register Native Method StackMethod Area적재된 ByteCode들을 분석하여 클래스의 타입,변수,메소드 등의 정보를 저장한다. 이때 Class변수(static)도 함께 생성된다. 해당 영역은 정보만 저장할 뿐, 실제 데이터는 Heap에서 인스턴스하고 관리된다.Heap클래스를 동적으로 생성하면 인스턴스가 메모리에 할당되는 영역이다. 또한 GC(Garbage Collection)의 대상이다. Method Area, Heap은 모든 Thread가 메모리를 공유하는 영역이다.Stack메소드가 호출될 때 메소드의 스택프레임이 저장되는 영역.메소드가 호출되면 메소드의 지역변수, 매개변수 등 스택프레임에 저장하여 관리한다. 메소드가 호출이 완료되면 해당 스택프레임은 메모리에서 해재된다.PC RegisterThread가 생성될 때 마다 생기는 메모리영역으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 한다.Native Method Stack자바 이외의 언어에서 제공되는 Method의 정보가 저장 되는 공간, JNI(Java Native Interface)를 통해 ByteCode로 변환 해준다. Stack, PC Register, Native Method Stack은 각각 Thread마다 독립적으로 생성되는 영역이다.Execution EngineClass Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.최초 JVM 이 나왔을 당시에는 Interpreter방식(한 줄씩 해석하고 실행)이였기 때문에 속도가 느리다는 단점이 있었지만 JIT compliler 방식을 통해 이 점을 보완했다." }, { "title": "String, String Builder, and String Buffer", "url": "/posts/API-String/", "categories": "JAVA, JAVA Basic", "tags": "JAVA, String", "date": "2022-04-08 10:59:10 +0900", "snippet": "#String 클래스자바에서 문자열을 처리하는 클래스는 String, String Builder, String Buffer 가 존재한다.Q. 이 3가지의 차이점은 무엇인가? 우선 String(불변,Immutable)과 StringBuilder,StringBuffer(가변,mutable)으로 구분할 수 있다. String 클래스는 한번 메모리에 올라간 후, 수정이 발생하면 그의 메모리의 값을 변경하는 것이 아닌, 또 다른 객체를 생성하여 새롭게 메모리 참조를 하게된다. 이러한 이유로 String 에 대한 문자열 연산이 빈번할 수록 성능이 저하될 수 있다.Q. 이런 단점이 존재하는데 왜 사용하는걸까? 대부분의 문자열은 복잡한 연산을 처리하기 보다, 한번 설정된 문자열을 여러곳에서 공유하는 경우가 많다.따라서 객체 또는 쓰레드에서의 공유에서 synchronization(동기화)와 같은 장치가 없어도 안전하게 공유 할 수 있다. StringBuilder,StringBuffer 클래스는 한번 메모리에 올라간 후, 수정이 발생하면 새로 객체를 만드는 것이 아닌,기존의 메모리의 값을 변경한다. 문자열 연산이 빈번한 경우 String 대신 사용하면 성능이 좋다.Q. StringBuilder,StringBuffer의 차이점은? 동기화 유무에 따른 멀티쓰레드에서의 안전성이다.StringBuilder 는 동기화를 지원하지 않는다. 단일 쓰레드에서의 문자열 연산에 유리하다.StringBuffer 는 동기화를 지원한다. 멀티 쓰레드에서 사용해도 안전하게 문자열 연산을 처리 할 수 있다. 하지만 성능면에서 가장 느리다. NOTE String객체 생성에는 2가지 방법이 존재한다 리터럴 선언 new 생성자 호출 리터럴 선언 의 경우, String constant pool을 참조.동일한 값이 있을 겨우, 해당 주소를 반환.동일한 값이 없을 경우, 새로운 주소에 값을 저장. JAVA8부터 StringPool은 Perm영역에서 Heap영역으로 이동(OOM문제로 인해), GC대상으로 변경됨. new 생성자 호출 의 경우, 동일한 값이 존재 여부에 상관없이 새로운 객체를 생성.public class StringMemoryIntern { public static void main(String... args) { String l1 = &quot;str&quot;; // 리터럴 선언 String l2 = &quot;str&quot;; // 리터럴 선언 String o1 = new String(&quot;str&quot;); // 생성자 호출 String o2 = new String(&quot;str&quot;); // 생성자 호출 // == 연산자는 객체의 메모리 주소를 비교하는 연산자이다.(값을 비교하지 않음) System.out.println(l1 == l2); // true String pool참조에 의해 동일한 메모리 주소 참조 System.out.println(l1 == o1); // false o1은 새로운 객체에 생성되어 메모리 주소가 다름 System.out.println(o1 == o2); // false o1, o2는 각각 다른 객체이기 떄문에 메모리 주소가 다름 // equals()메소드는 메모리의 값을 비교. 주소값이 달라도 메모리의 값을 비교한다. System.out.println(l1.equals(o1)); // true System.out.println(o1.equals(o2)); // true }} 클래스(java.lang) 상세 Thread Safe(동기화) String 문자열을 저장하고 여러가지 정보를 얻을 때 사용 O StringBuilder 문자열을 저장하고 내부 문자열을 조작할 때 사용 X StringBuffer 문자열을 저장하고 내부 문자열을 조작할 때 사용 O #String 문자열을 저장하고 여러 가지 정보를 얻을 때 사용문자열의 수정이 일어 날 경우, 해당 String객체를 수정하는 것이 아닌 새로운 String객체를 생성(=불변). #String Builder, String Buffer 내부 Buffer(:데이터를 임시로 저장하는 메모리)에 문자열을 저장해두고, 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다. 즉, String처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있다. String Builder 단일 스레드 환경에서만 사용하도록 설계 String Buffer 멀티 스레드 환경에서 사용할 수 있도록 동기화가 적용되어 있다(thread-safe) " }, { "title": "Collection", "url": "/posts/API-C/", "categories": "JAVA, JAVA Basic", "tags": "JAVA, Collection", "date": "2022-04-07 10:59:10 +0900", "snippet": "JCF(Java Collections Framework) " }, { "title": "JAVA Basic", "url": "/posts/JAVA/", "categories": "JAVA, JAVA Basic", "tags": "JAVA", "date": "2022-04-05 10:59:10 +0900", "snippet": "#01. JAVA란? 개발목적: 모든 가전제품에서 동작는 프로그램 개발 객체 지향 프로그래밍 언어(Object-Oriented Programming Language)각각의 데이터 중에서 관련있는 것들을 결합 또는 분리하여 객체들을 만든 후,객체 간 상호작용(메세지 전달)을 통하여 처리하는 언어 WORA(Write Once Run Anywhere)한번 작성한 코드를 모든 플랫폼에서 실행가능. #02. JAVA의 특징 OOP: 부품처럼 분담하여 개발이 가능 / 유지보수 용이 / 중복 최소화 / 생산성 / 일관성 JVM: 자바가상머신에서 실행되기 떄문에 실행환경에 구속받지 않음 GC : 메모리를 시스템이 관리 Multi-Thread: 자원을 공유하며, 동시에 여러개의 처리를 수행(자원 생성, 관리등의 중복최소화 / 처리속도 상승) #03. JAVA의 high performance가 가능한 이유는? JIT(Just in Time) 컴파일러: JAVA는 컴파일러와 인터프리터의 방식을 모두 사용 소스를 실행하기 위해서는 컴파일된 바이트코드를 기계어로 변환하는 작업이 필요(인터프리터).하지만 변환작업은 시간이 많이 필요하기 떄문에 이를 보완하기 위한 JIT 컴파일러 사용.이전에 변환한 코드는 캐시에 보관. 이후 동일한 코드를 호출할 경우 인터프리터를 이용하지 않고 저장해둔 캐시에서 불러옴#04. 클래스란? 객체의 상태와 행위를 정의한 설계도 #05. 생성자란? 클래스의 인스턴스 생성시 호출하는 메소드(=초기화) 클래스 이름과 동일한 메소드명 사용 사용자가 선언하지 않았을 경우, 컴파일러가 자동으로 기본생성자를 삽입 오버로드 가능 #06. 지역변수/인스턴스변수/클래스변수란? 지역변수 메소드 내부에서 선언하고, 메소드의 scope 내에서 사용 가능한 변수 인스턴스 변수 클래스에 선언된 변수, 클래스의 인스턴스가 생성 및 유지되는 동안 사용 가능 클래스 변수 클래스에 선언된 static변수, 클래스가 메모리에 올라가 있는 동안 사용 가능 #07. 객체(Object)란? 자신의 속성을 갖고 다른 것과 식별 가능한 것(인스턴스 상태)Q. 클래스와 객체는 다른것인가?그렇다. 클래스는 객체를 생성하기 위한(인스턴스, 메모리에 적재) 설계도이다.따라서 클래스와 객체는 서로 다른 개념이다. #08. OOP개념 상속 상위 개념을 물려받아 더 구체적이거나 넓게 확장하는 것 추상화 복잡한 것을 단순하게 표현한 것 / 포괄적인 상위 개념 캡슐화 내부 동작을 모르더라도, 사용법만 알면 쓸 수 있도록 내부를 감추는 방법 다형성 동일한 기능으로 다른 행위를 할 수 있는 것상속(추상클래스, 인터페이스) 오버라이드, 오버로딩 #09. 상속(Inheritance)이란? 상위 개념을 하위 개념이 물려받아 그 기능을 확장하는 것= 기본클래스(base class)의 특징을 파생클래스(derive class)가 상속받는 것= 기존 내용에 새로운 내용을 덧붙여 확장하거나 새롭게 변경하는것 코드의 재사용 / 일관성 / 유지보수 용이 / 중복 최소화#10. 캡슐화(Encapsulation)란? 내부 정보(디테일한 구현이나 내부 데이터)를 모르더라도, 동작만 알면 쓸 수 있도록 내부를 감추는 방법접근제어자: private, public, protected, default 정보은닉 / 접근제한 / 느슨한 결합(Loose Coupling)#11. 다형성(Polymorphism)이란? 다양한 형태를 갖는다.= 동일한 기능이라도 각각의 구현된 내용은 다를 수 있다. 상속(추상클래스, 인터페이스 구현) / 오버라이딩 / 오버로딩#12. 오버라이딩이란? 기존클래스로 부터 상속받은 기능에 새로운 기능을 추가하거나 변경하여 재정의 하는것 코드 재사용성, 구현의 구체화#13. 오버로딩이란? 한 클래스의 동일한 메소드를 여러개 정의 하는 것(매개변수의 타입,순서 등의 변화주어 구분한다)동일한 기능을 하는 메소드를 각각 다른 이름으로 정의 할 경우, 모든 메소드에 대해 일일이 구분해서 사용해야 하는 번거로움을 방지하는 목적 #14. 인터페이스란? 객체의 메소드를 정의한 타입개발자는 인터페이스의 구체화된 메소드를 모르더라도 그 메소드의 사용방법과 목적만 알면 사용 할 수 있다.객체의 교환성을 높여주기 떄문에 다형성을 만족한다.#15. 추상클래스란? 하위 클래스들로부터 공통적인 특성을 추출해 정의한 클래스추상클래스를 상속받는 하위 클래스들의 규격을 제시해준다. 공통 변수, 메소드를 통일 할 목적 코드 재사용 - 구현에 집중 추상클래스를 상속받은 하위 클래스들의 규격 통일 Q #24) What is the meaning of Collections in Java? 자바에서 Collection 이란Q #25) What are all the Classes and Interfaces that are available in the collections? Collection에서 사용 할 수 있는 클레스와 인터페이스는?Q #27) Explain the different lists available in the collection. Collection에서 사용가능한 다른 List들을 설명하시오Q #28) Explain about Set and their types in a collection. Set이란. collection 에서의 타입은?Q #29) Explain about Map and its types. Map이란 그의 타입은?Q #26) What is meant by Ordered and Sorted in collections? by Oredred, Sorted 란Q #17) Difference between Array and Array List. 배열과 리스트배열의 차이Q #30) Explain the Priority Queue. Priority Queue란Q #31) What is meant by Exception? Exceiption이란Q #32) What are the types of Exceptions? Excetion의 종류Q #33) What are the different ways to handle exceptions? exception을 다룰수 있는 다른 방법은?Q #34) What are the advantages of Exception handling? Exception handing의 이점Q #36) Explain about Exception Propagation. 예외 전파란Q #38) What is a Thread? 쓰레드란Q #39) How do you make a thread in Java? 쓰레드는 어떻게 만드는가Q #40) Explain about join () method. join에 대해 설명하시오Q #41) What does the yield method of the Thread class do? 양보메소드란?Q #42) Explain about wait () method. wait메소드에 대해 설명하시오Q #43) Difference between notify() method and notifyAll() method in Java. notify와 notifyAll의 차이점은?Q #44) How to stop a thread in java? Explain about sleep () method in a thread? 자바에서 스레드는 어떻게 중지시키는가sleep에대해 설명하시오Q #45) When to use the Runnable interface Vs Thread class in Java? runnable interface와 thread class는 언제 사용하는가Q #46) Difference between start() and run() method of thread class. 스레드클레스에서 start와 run의 차이점Q #47) What is Multi-threading? 멀티스레드란Q #48) Explain the thread life cycle in Java.ㅆ 쓰레드의 라이프사이클을 섬령하시오Q #49) What is Synchronization? 동기화란Q #50) What is the disadvantage of Synchronization? 동기화의 단점Q #51) What is meant by Serialization? 직렬화란Q #52) What is the purpose of a transient variable? 직렬화에서 transient 변수를 사용하는 목적은Q #53) Which methods are used during the Serialization and Deserialization process? 직렬화, 역직렬화 처리에서 사용되는 메소드는?Q #54) What is the purpose of a Volatile Variable? Volatile variable values are always read from the main memory and not from thread’s cache memory.Q #55) Difference between Serialization and Deserialization in Java. 직렬화, 역질렬화의 차이Q #56) What is SerialVersionUID? serialVersionUID란" } ]
