---
layout: post
title: 스레드(Thread)
date: '2022-04-17 00:59:10 +0900'
description: '스레드 알아보기'
categories: [JAVA, Basic]
img: ''
tags: [JAVA, Thread]
---
# 스레드란?
<hr>
![스레드(Thread)](https://user-images.githubusercontent.com/103012019/163682089-adb10d41-99c8-499b-abbe-8b5122aa2c6d.png)  
__`프로그램`__: 실행파일  
__`프로세스`__: CPU를 차지하면서 수행하는 주체, 프로그램의 인스턴스  
__`스레드`__: 프로세스 내부에서 자원을 공유하며 처리하는 단위, 작업을 효율적으로 처리하기 위한 모델  

# 스레드 종류
<hr>
* __`일반 스레드(User Thread)`__ = Main Thread() or 개발자가 구현한 스레드...  
* __`데몬 스레드(Daemon Thread)`__ = 데몬 스레드는 일반 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드. ex) GC  
![img1 daumcdn](https://user-images.githubusercontent.com/103012019/163742793-5081a215-0e1b-4d4d-8124-c79ab2e1a24b.png)  

__<mark>NOTE</mark>__  
> * 모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작된다.  
> `싱글 스레드` 같은 경우 Main Thread가 종료되면 프로세스도 종료되지만,  
> `멀티 스레드`는 Main Thread가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.  
> * 주 스레드가 종료되면 데몬 스레드 더는 존재 의미가 없기에 강제로 종료된다.  
> * setDaemon(Boolean) 메소드: 일반 스레드 -> 데몬 스레드 생성, 데몬 스레드 -> 일반 스레드 생성이 가능하다.  
> * setDeamon메소드는 스레드가 실행되기 전에 만 호출 할 수 있다. A스레드를 Thread.start() 이후 A스레드.setDaemon()메소드가 호출되면  IlegalThreadStateException 예외가 발생한다.  

# 스레드 생성  
<hr>
* java.lang.Thread
* java.lang.Runnable

## 방법1 extends Thread
```java
public class CustomThread extends Thread {
    
    @Override
    public void run() {
        int sum = 0;
        for (int index = 0; index < 10; index++) {
            sum += index;
            System.out.println(sum);
        }
        System.out.println("result : " + sum);

    }
}
```
```java
public static void main(String args[]){
    Thread subTread1 = new CustomThread();
    Thread subTread2 = new CustomThread();
    subTread1.start();
    subTread2.start();
}
```

## 방법2 implements Runnable  
```java
public class Task implements Runnable {

    @Override
    public void run() {
        int sum = 0;
        for (int index = 0; index < 10; index++) {
            sum += index;
            System.out.println(sum);
        }
        System.out.println("result : " + sum);
    }

}
```
```java
public static void main(String args[]){
    Runnable task = new Task();
    Thread subTread1 = new Thread(task);
    Thread subTread2 = new Thread(task);
    subTread1.setName("스레드 1번.");
    subTread2.setName("스레드 2번.");
    subTread1.start();
    subTread2.start();
}
```

__<mark>NOTE</mark>__  
> * run() 메소드가 종료되면 스레드는 종료된다.
> * 한 번 종료된 스레드는 다시 시작할 수 없다 = 다시 스레드 객체를 생성하고 등록해야 한다.
> * 스레드는 다른 스레드를 강제종료 시킬 수 있다.

# 스레드 상태
![1_Dfl8EQlWdIebwAh9UinLMA](https://user-images.githubusercontent.com/103012019/163746141-456bc1f4-790f-4f59-a98b-0459e4f7c9bf.jpg)  
* NEW : 스레드가 생성되었지만, 아직 실행할 준비가 되지 않은 상태.
* RUNNABLE : Thread.start() 호출 이후, 스케쥴링을 기다리고있는 실행준비 상태.
* RUNNING : RUNNABLE에서 선택되어 실제로 TASK가 수행되는 상태.
* WAITING : wait(), join() 호출 이후의 상태. 다른 스레드가 notify(), notifyAll()을 호출하기 까지 상태 유지.
* TIMED_WAITING : sleep(n), wait(n)을 호출하여 n ms동안 잠을 자는 상태.
* BLOCKED : 스레드가 I/O 작업 요청을 하면 JVM이 자동으로 BLOCK. BLOCK해제 시 자동으로 RUNNABLE로 상태로 전환.
* TERMINATED : 스레드 종료.

> __스레드 메소드__  
> interrupt(), sleep(), join(), wait(), yield(), notify(), notifyAll()  
> `sleep()` vs `wait()`: 점유자원 해제유무  
> `join()`: 다른 스레드들이 종료되기를 기다리고, 최종적으로 해당 스레드의 처리 수행
> `interrupt()`: 점유자원을 해제하고 해당 스레드 강제 종료
> `yield()`: 해당 스레드 상태를 RUNNING -> RUNNABLE로 전환하여 우선순위를 뒤로 미루고 , 다른 스레드를 우선으로 실행  
> `notify()`: WATTING상태의 스레드에게 알리고, 그 스레드의 상태를 WATTING -> RUNNABLE로 전환시킴
> `notifyAll()`: `notify()`와 동일하지만, WATTING상태의 모든 스레드에게 알림

# 스레드 그룹
용도에 따라 스레드를 그룹으로 나누고 관리 할 수 있다.
