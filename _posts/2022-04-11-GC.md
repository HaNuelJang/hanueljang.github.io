---
layout: post
title: Garbage Collection
date: '2022-04-11 10:59:10 +0900'
description: 'JAVA의 Garbage Collection을 알아보자.'
categories: [JAVA, JVM]
img: ''
tags: [JAVA, GC]
---
# 1. GC(Grabage Collection)
<hr>
자동으로 `Heap영역`의 메모리를 관리하는 쓰레드. Heap에서 Unreachable Object들을 mark후 sweep하는 작업을 처리하여 Heap을 확보한다. Heap은 다음과 같은 영역으로 나뉜다.  

![image](https://user-images.githubusercontent.com/103012019/162654143-40796a83-7c79-4c10-9769-291d9945d03f.png)

* YG(Minor GC)  
__`Eden`__: 처음 객체가 생성될 때 적재되는 공간  
__`Survivor1,2`__: Eden의 메모리가 가득차면 `Minor GC`가 발생한다. 이때 reachable Object를 Survivor영역으로 옮기는 작업을 한다.(단, Survivor영역의 한곳은 항상 비워둔다.)  

* OG(Major GC)  
YG영역에서 장기간 살아남은 객체는 OG로 이동하게 된다.

> __YG/OG비교__  
> 메모리 크기: YG < OG  
> 처리빈도: YG > OG  
>
> <mark>Why?</mark> 대체로 객체는 장시간 참조되지 않는다. 그리고 오래된 객체는 대부분 새로 생성된 객체를 참조하지 않는다. 따라서 YG의 `Minor GC`는 빈번하게 처리된다.  
> ![jsgct_dt_003_alc_vs_srvng](https://user-images.githubusercontent.com/103012019/162831662-f832b879-4e23-4372-864d-d0c182e9c4ed.png)

## GC시나리오
1. Eden이 가득차면 reachable Object을 탐색하고 Survivor1로 옮긴다. (Eden 메모리 초기화)  
2. 다음 `Minor GC`에서는 Eden, Survivor1을 탐색하고 Survivor2로 옮긴다. (Eden, Survivor1 메모리 초기화)  
3. 다음 `Minor GC`에서는 Eden, Survivor2를 탐색하고 Survivor1로 옮긴다. (Eden, Survivor2 메모리 초기화)  
4. 이 작업이 반복되면서 Survivor영역의 객체들은 Age값을 갖고, Survivor영역에서 다른 Survivor영역으로 이동될때 Age값이 증가한다. 
5. Age값이 설정된 임계치를 넘게되면, 해당 객체들은 OG영역으로 이동하게 된다.
6. OG의 메모리가 가득차면, `Magor GC`가 발생한다. OG의 reachable Object들을 탐색 후, 메모리를 정리한다.  

<img src="https://user-images.githubusercontent.com/103012019/162663678-68c1c8d9-3bd2-486b-b8a5-e56661c6ca3f.png" width="450" height="400">  
<img src="https://user-images.githubusercontent.com/103012019/162663759-0c1075b8-c29a-43df-b864-c5cd2d293cf8.png" width="450" height="408">  
<img src="https://user-images.githubusercontent.com/103012019/162664095-d8118ca7-00e9-4905-8583-ad37c5ada57f.png" width="450" height="400">  

# 2. GC알고리즘
<hr>  
* Serial GC
* Parallel GC
* CMS (Concurrent Mark & Sweep) GC
* 가비지 퍼스트 GC(G1GC)  
