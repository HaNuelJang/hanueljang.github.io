---
layout: post
title: Garbage Collection
date: '2022-04-11 10:59:10 +0900'
description: 'JAVA의 Garbage Collection을 알아보자.'
categories: [JAVA, JVM]
img: ''
tags: [JAVA, GC]
---
# 1. GC(Grabage Collection)
<hr>
자동으로 `Heap영역`의 메모리를 관리하는 쓰레드. Heap에서 Unreachable Object들을 mark후 sweep하는 작업을 처리하여 Heap을 확보한다. Heap은 다음과 같은 영역으로 나뉜다.  

![java-memory-management_gc-6](https://user-images.githubusercontent.com/103012019/162836156-77050729-7c4b-4601-a076-e10ce7fb1b81.png)

* YG(Minor GC)  
__`Eden`__: 처음 객체가 생성될 때 적재되는 공간  
__`Survivor1,2`__: Eden의 메모리가 가득차면 `Minor GC`가 발생한다. 이때 reachable Object를 Survivor영역으로 옮기는 작업을 한다.(단, Survivor영역의 한곳은 항상 비워둔다.)  

* OG(Major GC)  
YG영역에서 장기간 살아남은 객체는 OG로 이동하게 된다.  
<br>

__<mark>Metaspace</mark>__(~Java7까지 Permanent영역)  
> * Permanent Generation은 힙 메모리 영역중에 하나로 자바 애플리케이션을 실행할때 클래스의 메타데이터(클래스의 이름, 생성자, 필드, 메소드 정보...)를 저장하는 영역이다.(Java 7기준)
> * OutOfMemoryError: PermGen Space error 는 더이상 볼 수 없고 JVM 옵션으로 사용했던 PermSize 와 MaxPermSize는 더이상 사용할 필요가 없다. 이 대신에 MetaspaceSize 및 MaxMetaspaceSize가 새롭게 사용되게 되었다.  
> 
> 기존 Permanent영역은 고정된 크기로 할당되었다. 하지만 동적으로 생성되는 Class데이터들로 이로인해 OOM관련 이슈가 존재했었다. 이를 해결하기 위해 OS레벨에서 관리되는 Native메모리 영역으로 변경되면서, 개발자는 Metaspace의 영역에 대해 크게 의식할 필요가 없어지게 되었다.  
<br>  

__<mark>YG/OG비교</mark>__  
> 메모리 크기: YG < OG  
> 처리빈도: YG > OG  
>
> <mark>Why?</mark> 대체로 객체는 장시간 참조되지 않는다. 그리고 오래된 객체는 대부분 새로 생성된 객체를 참조하지 않는다. 따라서 YG의 `Minor GC`는 빈번하게 처리된다.  
> ![jsgct_dt_003_alc_vs_srvng](https://user-images.githubusercontent.com/103012019/162831662-f832b879-4e23-4372-864d-d0c182e9c4ed.png)

## #GC시나리오
1. Eden이 가득차면 reachable Object을 탐색하고 Survivor1로 옮긴다. (Eden 메모리 초기화)  
2. 다음 `Minor GC`에서는 Eden, Survivor1을 탐색하고 Survivor2로 옮긴다. (Eden, Survivor1 메모리 초기화)  
3. 다음 `Minor GC`에서는 Eden, Survivor2를 탐색하고 Survivor1로 옮긴다. (Eden, Survivor2 메모리 초기화)  
4. 이 작업이 반복되면서 Survivor영역의 객체들은 Age값을 갖고, Survivor영역에서 다른 Survivor영역으로 이동될때 Age값이 증가한다. 
5. Age값이 설정된 임계치를 넘게되면, 해당 객체들은 OG영역으로 이동하게 된다.
6. OG의 메모리가 가득차면, `Magor GC`가 발생한다. OG의 reachable Object들을 탐색 후, 메모리를 정리한다.  

<img src="https://user-images.githubusercontent.com/103012019/162663678-68c1c8d9-3bd2-486b-b8a5-e56661c6ca3f.png" width="450" height="400">  
<img src="https://user-images.githubusercontent.com/103012019/162663759-0c1075b8-c29a-43df-b864-c5cd2d293cf8.png" width="450" height="408">  
<img src="https://user-images.githubusercontent.com/103012019/162664095-d8118ca7-00e9-4905-8583-ad37c5ada57f.png" width="450" height="400">  

# 2. GC알고리즘
<hr>  
* Serial GC
* Parallel GC
* CMS (Concurrent Mark & Sweep) GC
* 가비지 퍼스트 GC(G1GC)  

## 1) Serial GC  
Heap의 앞부분부터 확인(Mark)하여 살아있는 것만 남기고(Sweep), 객체들이 연속되도록 Compaction 하는 작업  
기본적인 `Mark-Sweep-Compaction` 알고리즘에 해당  
싱글 쓰레드로 작업을 수행하며, Stop-The-World 시간이 상대적으로 길다.(서버환경에서는 사용하지 않는것이 바람직하다)  
```java
/* 사용옵션 */
-XX:+UseSerialGC
```

## 2) Parallel GC  
Serial GC의 멀티 쓰레드 방식  
```
/* 사용옵션 */
-XX:+UseParallelGC     //Minor GC만 멀티 스레드로 동작하고, Major GC는 싱글 스레드 동작  
-XX:+UseParallelOldGC  //Minor GC, Major GC 멀티 스레드로 동작  

/* 스레드 수 변경 옵션 */  
/* 기본적으로 JVM이 구동되는 환경의 CPU 코어 개수에 맞춰서 N개의 GC가 수행된다. */  
-XX:ParallelGCThreads=N(스레드수)
```

## 3) Parallel Old GC  
Parallel GC와 다른점은 `Mark-Summary-Compaction` 단계를 거쳐서 객체를 식별  
Summary 에 해당하는 작업이 GC를 수행한 영역에 대해서 살아있는 객체를 식별한다는 작업  
```
/* 사용옵션 */
-XX:+UseParallelOldGC  //Minor GC, Major GC 멀티 스레드로 동작  
```

## 4) CMS GC(Concurrent Mark & Sweep GC)  
Compaction 을 진행하지는 않는다.  
Stop-The-World 시간이 짧고, Ma
1. Initial Mark: GC Tree의 Root중 살아있는 객체만 선별(STW시간이 매우 짧다.)
3. Concurrent Mark: Mark단계에서 선별된 객체부터 Tree탐색을 하면서 참조중인 살아있는 객체를 확인한다.  
4. Remark: 위 단계를 한번더 검증한다.(새로 추가되거나 참조가 끊긴 객체를 확인한다. STW발생-멀티쓰레드로 동작)  
5. Concurrent Sweep: GC대상을 정리한다.  
```
/* 사용옵션 */
-XX:+UseConcMarkSweepGC
```

## 5) G1 GC(Garbage First GC)  
JDK7 부터 공식적으로 도입된 서버형 GC.  대용량 메모리에 적합한 솔루션을 제공하기 위해 사용한다.  
JDK11 부터 공식적인 GC알고리즘으로 적용.
> G1 GC는 메모리를 페이징 하듯이 논리적인 단위(Region)로 나눠서 관리한다는 것이다.  
> Region이라는 논리적인 단위로 메모리를 관리하여 CMS와 달리 Compaction 단계를 진행하고 메모리 단편화 문제를 없앴다.  
> 또한 STW의 시간을 예측할 수 있다는 것이 G1 GC의 큰 장점 중 하나이다.
